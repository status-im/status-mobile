// DO NOT EDIT: code is autogenerated by go2nodebinding from Go code.
// https://github.com/divan/go2nodebinding

#include <node.h>

#include "../../../result/libstatus.h"

namespace status {

using v8::Exception;
using v8::FunctionCallbackInfo;
using v8::Function;
using v8::Persistent;
using v8::Context;
using v8::NewStringType;
using v8::Isolate;
using v8::Local;
using v8::Object;
using v8::String;
using v8::Number;
using v8::Value;


void _MultiAccountGenerateAndDeriveAddresses(const FunctionCallbackInfo<Value>& args) {
	Isolate* isolate = args.GetIsolate();
        Local<Context> context = isolate->GetCurrentContext();

	if (args.Length() != 1) {
		// Throw an Error that is passed back to JavaScript
		isolate->ThrowException(Exception::TypeError(
			String::NewFromUtf8Literal(isolate, "Wrong number of arguments for MultiAccountGenerateAndDeriveAddresses")));
		return;
	}

	// Check the argument types

	if (!args[0]->IsString()) {
		isolate->ThrowException(Exception::TypeError(
			String::NewFromUtf8Literal(isolate, "Wrong argument type for 'paramsJSON'")));
		return;
	}


	String::Utf8Value arg0Obj(isolate, args[0]->ToString(context).ToLocalChecked());
	char *arg0 = *arg0Obj;

	// Call exported Go function, which returns a C string
	char *c = MultiAccountGenerateAndDeriveAddresses(arg0);

	Local<String> ret = String::NewFromUtf8(isolate, c).ToLocalChecked();
	args.GetReturnValue().Set(ret);
	delete c;


}

void _MultiAccountImportPrivateKey(const FunctionCallbackInfo<Value>& args) {
	Isolate* isolate = args.GetIsolate();
        Local<Context> context = isolate->GetCurrentContext();

	if (args.Length() != 1) {
		// Throw an Error that is passed back to JavaScript
		isolate->ThrowException(Exception::TypeError(
			String::NewFromUtf8Literal(isolate, "Wrong number of arguments for MultiAccountImportPrivateKey")));
		return;
	}

	// Check the argument types

	if (!args[0]->IsString()) {
		isolate->ThrowException(Exception::TypeError(
			String::NewFromUtf8Literal(isolate, "Wrong argument type for 'paramsJSON'")));
		return;
	}


	String::Utf8Value arg0Obj(isolate, args[0]->ToString(context).ToLocalChecked());
	char *arg0 = *arg0Obj;

	// Call exported Go function, which returns a C string
	char *c = MultiAccountImportPrivateKey(arg0);

	Local<String> ret = String::NewFromUtf8(isolate, c).ToLocalChecked();
	args.GetReturnValue().Set(ret);
	delete c;


}

void _MultiAccountLoadAccount(const FunctionCallbackInfo<Value>& args) {
	Isolate* isolate = args.GetIsolate();
        Local<Context> context = isolate->GetCurrentContext();

	if (args.Length() != 1) {
		// Throw an Error that is passed back to JavaScript
		isolate->ThrowException(Exception::TypeError(
			String::NewFromUtf8Literal(isolate, "Wrong number of arguments for MultiAccountLoadAccount")));
		return;
	}

	// Check the argument types

	if (!args[0]->IsString()) {
		isolate->ThrowException(Exception::TypeError(
			String::NewFromUtf8Literal(isolate, "Wrong argument type for 'paramsJSON'")));
		return;
	}


	String::Utf8Value arg0Obj(isolate, args[0]->ToString(context).ToLocalChecked());
	char *arg0 = *arg0Obj;

	// Call exported Go function, which returns a C string
	char *c = MultiAccountLoadAccount(arg0);

	Local<String> ret = String::NewFromUtf8(isolate, c).ToLocalChecked();
	args.GetReturnValue().Set(ret);
	delete c;
}

void _MultiAccountReset(const FunctionCallbackInfo<Value>& args) {
	Isolate* isolate = args.GetIsolate();

	if (args.Length() != 0) {
		// Throw an Error that is passed back to JavaScript
		isolate->ThrowException(Exception::TypeError(
			String::NewFromUtf8Literal(isolate, "Wrong number of arguments for MultiAccountReset")));
		return;
	}

	// Check the argument types


	// Call exported Go function, which returns a C string
	char *c = MultiAccountReset();

	Local<String> ret = String::NewFromUtf8(isolate, c).ToLocalChecked();
	args.GetReturnValue().Set(ret);
	delete c;
}

void _MultiAccountDeriveAddresses(const FunctionCallbackInfo<Value>& args) {
	Isolate* isolate = args.GetIsolate();
        Local<Context> context = isolate->GetCurrentContext();

	if (args.Length() != 1) {
		// Throw an Error that is passed back to JavaScript
		isolate->ThrowException(Exception::TypeError(
			String::NewFromUtf8Literal(isolate, "Wrong number of arguments for MultiAccountDeriveAddresses")));
		return;
	}

	// Check the argument types

	if (!args[0]->IsString()) {
		isolate->ThrowException(Exception::TypeError(
			String::NewFromUtf8Literal(isolate, "Wrong argument type for 'paramsJSON'")));
		return;
	}


	String::Utf8Value arg0Obj(isolate, args[0]->ToString(context).ToLocalChecked());
	char *arg0 = *arg0Obj;

	// Call exported Go function, which returns a C string
	char *c = MultiAccountDeriveAddresses(arg0);

	Local<String> ret = String::NewFromUtf8(isolate, c).ToLocalChecked();
	args.GetReturnValue().Set(ret);
	delete c;
}

void _MultiAccountImportMnemonic(const FunctionCallbackInfo<Value>& args) {
	Isolate* isolate = args.GetIsolate();
        Local<Context> context = isolate->GetCurrentContext();

	if (args.Length() != 1) {
		// Throw an Error that is passed back to JavaScript
		isolate->ThrowException(Exception::TypeError(
			String::NewFromUtf8Literal(isolate, "Wrong number of arguments for MultiAccountImportMnemonic")));
		return;
	}

	// Check the argument types

	if (!args[0]->IsString()) {
		isolate->ThrowException(Exception::TypeError(
			String::NewFromUtf8Literal(isolate, "Wrong argument type for 'paramsJSON'")));
		return;
	}


	String::Utf8Value arg0Obj(isolate, args[0]->ToString(context).ToLocalChecked());
	char *arg0 = *arg0Obj;

	// Call exported Go function, which returns a C string
	char *c = MultiAccountImportMnemonic(arg0);

	Local<String> ret = String::NewFromUtf8(isolate, c).ToLocalChecked();
	args.GetReturnValue().Set(ret);
	delete c;


}

void _MultiAccountGenerate(const FunctionCallbackInfo<Value>& args) {
	Isolate* isolate = args.GetIsolate();
        Local<Context> context = isolate->GetCurrentContext();

	if (args.Length() != 1) {
		// Throw an Error that is passed back to JavaScript
		isolate->ThrowException(Exception::TypeError(
			String::NewFromUtf8Literal(isolate, "Wrong number of arguments for MultiAccountGenerate")));
		return;
	}

	// Check the argument types

	if (!args[0]->IsString()) {
		isolate->ThrowException(Exception::TypeError(
			String::NewFromUtf8Literal(isolate, "Wrong argument type for 'paramsJSON'")));
		return;
	}


	String::Utf8Value arg0Obj(isolate, args[0]->ToString(context).ToLocalChecked());
	char *arg0 = *arg0Obj;

	// Call exported Go function, which returns a C string
	char *c = MultiAccountGenerate(arg0);

	Local<String> ret = String::NewFromUtf8(isolate, c).ToLocalChecked();
	args.GetReturnValue().Set(ret);
	delete c;
}

void _MultiAccountStoreDerivedAccounts(const FunctionCallbackInfo<Value>& args) {
	Isolate* isolate = args.GetIsolate();
        Local<Context> context = isolate->GetCurrentContext();

	if (args.Length() != 1) {
		// Throw an Error that is passed back to JavaScript
		isolate->ThrowException(Exception::TypeError(
			String::NewFromUtf8Literal(isolate, "Wrong number of arguments for MultiAccountStoreDerivedAccounts")));
		return;
	}

	// Check the argument types

	if (!args[0]->IsString()) {
		isolate->ThrowException(Exception::TypeError(
			String::NewFromUtf8Literal(isolate, "Wrong argument type for 'paramsJSON'")));
		return;
	}


	String::Utf8Value arg0Obj(isolate, args[0]->ToString(context).ToLocalChecked());
	char *arg0 = *arg0Obj;

	// Call exported Go function, which returns a C string
	char *c = MultiAccountStoreDerivedAccounts(arg0);

	Local<String> ret = String::NewFromUtf8(isolate, c).ToLocalChecked();
	args.GetReturnValue().Set(ret);
	delete c;
}

void _MultiAccountStoreAccount(const FunctionCallbackInfo<Value>& args) {
	Isolate* isolate = args.GetIsolate();
        Local<Context> context = isolate->GetCurrentContext();

	if (args.Length() != 1) {
		// Throw an Error that is passed back to JavaScript
		isolate->ThrowException(Exception::TypeError(
			String::NewFromUtf8Literal(isolate, "Wrong number of arguments for MultiAccountStoreAccount")));
		return;
	}

	// Check the argument types

	if (!args[0]->IsString()) {
		isolate->ThrowException(Exception::TypeError(
			String::NewFromUtf8Literal(isolate, "Wrong argument type for 'paramsJSON'")));
		return;
	}


	String::Utf8Value arg0Obj(isolate, args[0]->ToString(context).ToLocalChecked());
	char *arg0 = *arg0Obj;

	// Call exported Go function, which returns a C string
	char *c = MultiAccountStoreAccount(arg0);

	Local<String> ret = String::NewFromUtf8(isolate, c).ToLocalChecked();
	args.GetReturnValue().Set(ret);
	delete c;
}

void _InitKeystore(const FunctionCallbackInfo<Value>& args) {
	Isolate* isolate = args.GetIsolate();
        Local<Context> context = isolate->GetCurrentContext();

	if (args.Length() != 1) {
		// Throw an Error that is passed back to JavaScript
		isolate->ThrowException(Exception::TypeError(
			String::NewFromUtf8Literal(isolate, "Wrong number of arguments for InitKeystore")));
		return;
	}

	// Check the argument types

	if (!args[0]->IsString()) {
		isolate->ThrowException(Exception::TypeError(
			String::NewFromUtf8Literal(isolate, "Wrong argument type for 'keydir'")));
		return;
	}


	String::Utf8Value arg0Obj(isolate, args[0]->ToString(context).ToLocalChecked());
	char *arg0 = *arg0Obj;

	// Call exported Go function, which returns a C string
	char *c = InitKeystore(arg0);

	Local<String> ret = String::NewFromUtf8(isolate, c).ToLocalChecked();
	args.GetReturnValue().Set(ret);
	delete c;
}

void _StopCPUProfiling(const FunctionCallbackInfo<Value>& args) {
	Isolate* isolate = args.GetIsolate();

	if (args.Length() != 0) {
		// Throw an Error that is passed back to JavaScript
		isolate->ThrowException(Exception::TypeError(
			String::NewFromUtf8Literal(isolate, "Wrong number of arguments for StopCPUProfiling")));
		return;
	}

	// Check the argument types




	// Call exported Go function, which returns a C string
	char *c = StopCPUProfiling();

	Local<String> ret = String::NewFromUtf8(isolate, c).ToLocalChecked();
	args.GetReturnValue().Set(ret);
	delete c;


}

void _Identicon(const FunctionCallbackInfo<Value>& args) {
	Isolate* isolate = args.GetIsolate();
        Local<Context> context = isolate->GetCurrentContext();

	if (args.Length() != 1) {
		// Throw an Error that is passed back to JavaScript
		isolate->ThrowException(Exception::TypeError(
			String::NewFromUtf8Literal(isolate, "Wrong number of arguments for Identicon")));
		return;
	}

	// Check the argument types

	if (!args[0]->IsString()) {
		isolate->ThrowException(Exception::TypeError(
			String::NewFromUtf8Literal(isolate, "Wrong argument type for 'pk'")));
		return;
	}


	String::Utf8Value arg0Obj(isolate, args[0]->ToString(context).ToLocalChecked());
	char *arg0 = *arg0Obj;

	// Call exported Go function, which returns a C string
	char *c = Identicon(arg0);

	Local<String> ret = String::NewFromUtf8(isolate, c).ToLocalChecked();
	args.GetReturnValue().Set(ret);
	delete c;

}

void _Logout(const FunctionCallbackInfo<Value>& args) {
	Isolate* isolate = args.GetIsolate();

	if (args.Length() != 0) {
		// Throw an Error that is passed back to JavaScript
		isolate->ThrowException(Exception::TypeError(
			String::NewFromUtf8Literal(isolate, "Wrong number of arguments for Logout")));
		return;
	}

	// Check the argument types




	// Call exported Go function, which returns a C string
	char *c = Logout();

	Local<String> ret = String::NewFromUtf8(isolate, c).ToLocalChecked();
	args.GetReturnValue().Set(ret);
	delete c;


}

void _HashMessage(const FunctionCallbackInfo<Value>& args) {
	Isolate* isolate = args.GetIsolate();
        Local<Context> context = isolate->GetCurrentContext();

	if (args.Length() != 1) {
		// Throw an Error that is passed back to JavaScript
		isolate->ThrowException(Exception::TypeError(
			String::NewFromUtf8Literal(isolate, "Wrong number of arguments for HashMessage")));
		return;
	}

	// Check the argument types

	if (!args[0]->IsString()) {
		isolate->ThrowException(Exception::TypeError(
			String::NewFromUtf8Literal(isolate, "Wrong argument type for 'message'")));
		return;
	}


	String::Utf8Value arg0Obj(isolate, args[0]->ToString(context).ToLocalChecked());
	char *arg0 = *arg0Obj;

	// Call exported Go function, which returns a C string
	char *c = HashMessage(arg0);

	Local<String> ret = String::NewFromUtf8(isolate, c).ToLocalChecked();
	args.GetReturnValue().Set(ret);
	delete c;


}

void _ResetChainData(const FunctionCallbackInfo<Value>& args) {
	Isolate* isolate = args.GetIsolate();

	if (args.Length() != 0) {
		// Throw an Error that is passed back to JavaScript
		isolate->ThrowException(Exception::TypeError(
			String::NewFromUtf8Literal(isolate, "Wrong number of arguments for ResetChainData")));
		return;
	}

	// Check the argument types




	// Call exported Go function, which returns a C string
	char *c = ResetChainData();

	Local<String> ret = String::NewFromUtf8(isolate, c).ToLocalChecked();
	args.GetReturnValue().Set(ret);
	delete c;


}

void _SaveAccountAndLogin(const FunctionCallbackInfo<Value>& args) {
	Isolate* isolate = args.GetIsolate();
        Local<Context> context = isolate->GetCurrentContext();

	if (args.Length() != 5) {
		// Throw an Error that is passed back to JavaScript
		isolate->ThrowException(Exception::TypeError(
			String::NewFromUtf8Literal(isolate, "Wrong number of arguments for SaveAccountAndLogin")));
		return;
	}

	// Check the argument types

	if (!args[0]->IsString()) {
		isolate->ThrowException(Exception::TypeError(
			String::NewFromUtf8Literal(isolate, "Wrong argument type for 'accountData'")));
		return;
	}
	if (!args[1]->IsString()) {
		isolate->ThrowException(Exception::TypeError(
			String::NewFromUtf8Literal(isolate, "Wrong argument type for 'password'")));
		return;
	}
	if (!args[2]->IsString()) {
		isolate->ThrowException(Exception::TypeError(
			String::NewFromUtf8Literal(isolate, "Wrong argument type for 'settingsJSON'")));
		return;
	}
	if (!args[3]->IsString()) {
		isolate->ThrowException(Exception::TypeError(
			String::NewFromUtf8Literal(isolate, "Wrong argument type for 'configJSON'")));
		return;
	}
	if (!args[4]->IsString()) {
		isolate->ThrowException(Exception::TypeError(
			String::NewFromUtf8Literal(isolate, "Wrong argument type for 'subaccountData'")));
		return;
	}


	String::Utf8Value arg0Obj(isolate, args[0]->ToString(context).ToLocalChecked());
	char *arg0 = *arg0Obj;
	String::Utf8Value arg1Obj(isolate, args[1]->ToString(context).ToLocalChecked());
	char *arg1 = *arg1Obj;
	String::Utf8Value arg2Obj(isolate, args[2]->ToString(context).ToLocalChecked());
	char *arg2 = *arg2Obj;
	String::Utf8Value arg3Obj(isolate, args[3]->ToString(context).ToLocalChecked());
	char *arg3 = *arg3Obj;
	String::Utf8Value arg4Obj(isolate, args[4]->ToString(context).ToLocalChecked());
	char *arg4 = *arg4Obj;

	// Call exported Go function, which returns a C string
	char *c = SaveAccountAndLogin(arg0, arg1, arg2, arg3, arg4);

	Local<String> ret = String::NewFromUtf8(isolate, c).ToLocalChecked();
	args.GetReturnValue().Set(ret);
	delete c;

}

void _GenerateAlias(const FunctionCallbackInfo<Value>& args) {
	Isolate* isolate = args.GetIsolate();
        Local<Context> context = isolate->GetCurrentContext();

	if (args.Length() != 1) {
		// Throw an Error that is passed back to JavaScript
		isolate->ThrowException(Exception::TypeError(
			String::NewFromUtf8Literal(isolate, "Wrong number of arguments for GenerateAlias")));
		return;
	}

	// Check the argument types

	if (!args[0]->IsString()) {
		isolate->ThrowException(Exception::TypeError(
			String::NewFromUtf8Literal(isolate, "Wrong argument type for 'pk'")));
		return;
	}


	String::Utf8Value arg0Obj(isolate, args[0]->ToString(context).ToLocalChecked());
	char *arg0 = *arg0Obj;

	// Call exported Go function, which returns a C string
	char *c = GenerateAlias(arg0);

	Local<String> ret = String::NewFromUtf8(isolate, c).ToLocalChecked();
	args.GetReturnValue().Set(ret);
	delete c;

}

void _ValidateMnemonic(const FunctionCallbackInfo<Value>& args) {
	Isolate* isolate = args.GetIsolate();
        Local<Context> context = isolate->GetCurrentContext();

	if (args.Length() != 1) {
		// Throw an Error that is passed back to JavaScript
		isolate->ThrowException(Exception::TypeError(
			String::NewFromUtf8Literal(isolate, "Wrong number of arguments for ValidateMnemonic")));
		return;
	}

	// Check the argument types

	if (!args[0]->IsString()) {
		isolate->ThrowException(Exception::TypeError(
			String::NewFromUtf8Literal(isolate, "Wrong argument type for 'mnemonic'")));
		return;
	}


	String::Utf8Value arg0Obj(isolate, args[0]->ToString(context).ToLocalChecked());
	char *arg0 = *arg0Obj;

	// Call exported Go function, which returns a C string
	char *c = ValidateMnemonic(arg0);

	Local<String> ret = String::NewFromUtf8(isolate, c).ToLocalChecked();
	args.GetReturnValue().Set(ret);
	delete c;

}

void _MultiformatSerializePublicKey(const FunctionCallbackInfo<Value>& args) {
	Isolate* isolate = args.GetIsolate();
        Local<Context> context = isolate->GetCurrentContext();

	if (args.Length() != 2) {
		// Throw an Error that is passed back to JavaScript
		isolate->ThrowException(Exception::TypeError(
			String::NewFromUtf8Literal(isolate, "Wrong number of arguments for MultiformatSerializePublicKey")));
		return;
	}

	// Check the argument types

	if (!args[0]->IsString()) {
		isolate->ThrowException(Exception::TypeError(
			String::NewFromUtf8Literal(isolate, "Wrong argument type for 'key'")));
		return;
	}
	if (!args[1]->IsString()) {
		isolate->ThrowException(Exception::TypeError(
			String::NewFromUtf8Literal(isolate, "Wrong argument type for 'outBase'")));
		return;
	}


	String::Utf8Value arg0Obj(isolate, args[0]->ToString(context).ToLocalChecked());
	char *arg0 = *arg0Obj;
	String::Utf8Value arg1Obj(isolate, args[1]->ToString(context).ToLocalChecked());
	char *arg1 = *arg1Obj;

	// Call exported Go function, which returns a C string
	char *c = MultiformatSerializePublicKey(arg0, arg1);

	Local<String> ret = String::NewFromUtf8(isolate, c).ToLocalChecked();
	args.GetReturnValue().Set(ret);
	delete c;


}


void _SaveAccountAndLoginWithKeycard(const FunctionCallbackInfo<Value>& args) {
	Isolate* isolate = args.GetIsolate();
        Local<Context> context = isolate->GetCurrentContext();

	if (args.Length() != 6) {
		// Throw an Error that is passed back to JavaScript
		isolate->ThrowException(Exception::TypeError(
			String::NewFromUtf8Literal(isolate, "Wrong number of arguments for SaveAccountAndLoginWithKeycard")));
		return;
	}

	// Check the argument types

	if (!args[0]->IsString()) {
		isolate->ThrowException(Exception::TypeError(
			String::NewFromUtf8Literal(isolate, "Wrong argument type for 'accountData'")));
		return;
	}
	if (!args[1]->IsString()) {
		isolate->ThrowException(Exception::TypeError(
			String::NewFromUtf8Literal(isolate, "Wrong argument type for 'password'")));
		return;
	}
	if (!args[2]->IsString()) {
		isolate->ThrowException(Exception::TypeError(
			String::NewFromUtf8Literal(isolate, "Wrong argument type for 'settingsJSON'")));
		return;
	}
	if (!args[3]->IsString()) {
		isolate->ThrowException(Exception::TypeError(
			String::NewFromUtf8Literal(isolate, "Wrong argument type for 'configJSON'")));
		return;
	}
	if (!args[4]->IsString()) {
		isolate->ThrowException(Exception::TypeError(
			String::NewFromUtf8Literal(isolate, "Wrong argument type for 'subaccountData'")));
		return;
	}
	if (!args[5]->IsString()) {
		isolate->ThrowException(Exception::TypeError(
			String::NewFromUtf8Literal(isolate, "Wrong argument type for 'keyHex'")));
		return;
	}


	String::Utf8Value arg0Obj(isolate, args[0]->ToString(context).ToLocalChecked());
	char *arg0 = *arg0Obj;
	String::Utf8Value arg1Obj(isolate, args[1]->ToString(context).ToLocalChecked());
	char *arg1 = *arg1Obj;
	String::Utf8Value arg2Obj(isolate, args[2]->ToString(context).ToLocalChecked());
	char *arg2 = *arg2Obj;
	String::Utf8Value arg3Obj(isolate, args[3]->ToString(context).ToLocalChecked());
	char *arg3 = *arg3Obj;
	String::Utf8Value arg4Obj(isolate, args[4]->ToString(context).ToLocalChecked());
	char *arg4 = *arg4Obj;
	String::Utf8Value arg5Obj(isolate, args[5]->ToString(context).ToLocalChecked());
	char *arg5 = *arg5Obj;

	// Call exported Go function, which returns a C string
	char *c = SaveAccountAndLoginWithKeycard(arg0, arg1, arg2, arg3, arg4, arg5);

	Local<String> ret = String::NewFromUtf8(isolate, c).ToLocalChecked();
	args.GetReturnValue().Set(ret);
	delete c;


}

void _LoginWithKeycard(const FunctionCallbackInfo<Value>& args) {
	Isolate* isolate = args.GetIsolate();
        Local<Context> context = isolate->GetCurrentContext();

	if (args.Length() != 3) {
		// Throw an Error that is passed back to JavaScript
		isolate->ThrowException(Exception::TypeError(
			String::NewFromUtf8Literal(isolate, "Wrong number of arguments for LoginWithKeycard")));
		return;
	}

	// Check the argument types

	if (!args[0]->IsString()) {
		isolate->ThrowException(Exception::TypeError(
			String::NewFromUtf8Literal(isolate, "Wrong argument type for 'accountData'")));
		return;
	}
	if (!args[1]->IsString()) {
		isolate->ThrowException(Exception::TypeError(
			String::NewFromUtf8Literal(isolate, "Wrong argument type for 'password'")));
		return;
	}
	if (!args[2]->IsString()) {
		isolate->ThrowException(Exception::TypeError(
			String::NewFromUtf8Literal(isolate, "Wrong argument type for 'keyHex'")));
		return;
	}


	String::Utf8Value arg0Obj(isolate, args[0]->ToString(context).ToLocalChecked());
	char *arg0 = *arg0Obj;
	String::Utf8Value arg1Obj(isolate, args[1]->ToString(context).ToLocalChecked());
	char *arg1 = *arg1Obj;
	String::Utf8Value arg2Obj(isolate, args[2]->ToString(context).ToLocalChecked());
	char *arg2 = *arg2Obj;

	// Call exported Go function, which returns a C string
	char *c = LoginWithKeycard(arg0, arg1, arg2);

	Local<String> ret = String::NewFromUtf8(isolate, c).ToLocalChecked();
	args.GetReturnValue().Set(ret);
	delete c;


}

void _MultiformatDeserializePublicKey(const FunctionCallbackInfo<Value>& args) {
	Isolate* isolate = args.GetIsolate();
        Local<Context> context = isolate->GetCurrentContext();

	if (args.Length() != 2) {
		// Throw an Error that is passed back to JavaScript
		isolate->ThrowException(Exception::TypeError(
			String::NewFromUtf8Literal(isolate, "Wrong number of arguments for MultiformatDeserializePublicKey")));
		return;
	}

	// Check the argument types

	if (!args[0]->IsString()) {
		isolate->ThrowException(Exception::TypeError(
			String::NewFromUtf8Literal(isolate, "Wrong argument type for 'key'")));
		return;
	}
	if (!args[1]->IsString()) {
		isolate->ThrowException(Exception::TypeError(
			String::NewFromUtf8Literal(isolate, "Wrong argument type for 'outBase'")));
		return;
	}


	String::Utf8Value arg0Obj(isolate, args[0]->ToString(context).ToLocalChecked());
	char *arg0 = *arg0Obj;
	String::Utf8Value arg1Obj(isolate, args[1]->ToString(context).ToLocalChecked());
	char *arg1 = *arg1Obj;

	// Call exported Go function, which returns a C string
	char *c = MultiformatDeserializePublicKey(arg0, arg1);

	Local<String> ret = String::NewFromUtf8(isolate, c).ToLocalChecked();
	args.GetReturnValue().Set(ret);
	delete c;


}

void _Login(const FunctionCallbackInfo<Value>& args) {
	Isolate* isolate = args.GetIsolate();
        Local<Context> context = isolate->GetCurrentContext();

	if (args.Length() != 2) {
		// Throw an Error that is passed back to JavaScript
		isolate->ThrowException(Exception::TypeError(
			String::NewFromUtf8Literal(isolate, "Wrong number of arguments for Login")));
		return;
	}

	// Check the argument types

	if (!args[0]->IsString()) {
		isolate->ThrowException(Exception::TypeError(
			String::NewFromUtf8Literal(isolate, "Wrong argument type for 'accountData'")));
		return;
	}
	if (!args[1]->IsString()) {
		isolate->ThrowException(Exception::TypeError(
			String::NewFromUtf8Literal(isolate, "Wrong argument type for 'password'")));
		return;
	}


	String::Utf8Value arg0Obj(isolate, args[0]->ToString(context).ToLocalChecked());
	char *arg0 = *arg0Obj;
	String::Utf8Value arg1Obj(isolate, args[1]->ToString(context).ToLocalChecked());
	char *arg1 = *arg1Obj;

	// Call exported Go function, which returns a C string
	char *c = Login(arg0, arg1);

	Local<String> ret = String::NewFromUtf8(isolate, c).ToLocalChecked();
	args.GetReturnValue().Set(ret);
	delete c;


}

Local<Function> runCallbackCB;
Local<Context> runCallbackContext;
Isolate* runCallbackIsolate;

Persistent<Function> r_call;

void run(char *json) {
  printf("%s\n", json);
    if(!r_call.IsEmpty()) {
        v8::Isolate* isolate = v8::Isolate::GetCurrent();
        Local<Context> context = isolate->GetCurrentContext();
        v8::Local<v8::Function> func = v8::Local<v8::Function>::New(isolate, r_call);

        if (!func.IsEmpty()) {
            const unsigned argc = 1;
            v8::Local<v8::Value> argv[argc] =
                { v8::String::NewFromUtf8Literal(isolate, "hello world") };
            func->Call(context, v8::Null(isolate), argc, argv);
        }
    }
}


void _SetSignalEventCallback(const FunctionCallbackInfo<Value>& args) {
	Isolate* isolate = args.GetIsolate();

	if (args.Length() != 1) {
		// Throw an Error that is passed back to JavaScript
		isolate->ThrowException(Exception::TypeError(
			String::NewFromUtf8Literal(isolate, "Wrong number of arguments for StartCPUProfile")));
		return;
	}


        v8::Local<v8::Function> func = v8::Local<v8::Function>::Cast(args[0]);
        //v8::Function * ptr = *func;
        r_call.Reset(isolate, func);


        SetSignalEventCallback((void *)&run);
}



void _StartCPUProfile(const FunctionCallbackInfo<Value>& args) {
	Isolate* isolate = args.GetIsolate();
        Local<Context> context = isolate->GetCurrentContext();

	if (args.Length() != 1) {
		// Throw an Error that is passed back to JavaScript
		isolate->ThrowException(Exception::TypeError(
			String::NewFromUtf8Literal(isolate, "Wrong number of arguments for StartCPUProfile")));
		return;
	}

	// Check the argument types

	if (!args[0]->IsString()) {
		isolate->ThrowException(Exception::TypeError(
			String::NewFromUtf8Literal(isolate, "Wrong argument type for 'dataDir'")));
		return;
	}


	String::Utf8Value arg0Obj(isolate, args[0]->ToString(context).ToLocalChecked());
	char *arg0 = *arg0Obj;

	// Call exported Go function, which returns a C string
	char *c = StartCPUProfile(arg0);

	Local<String> ret = String::NewFromUtf8(isolate, c).ToLocalChecked();
	args.GetReturnValue().Set(ret);
	delete c;


}

void _OpenAccounts(const FunctionCallbackInfo<Value>& args) {
	Isolate* isolate = args.GetIsolate();
        Local<Context> context = isolate->GetCurrentContext();

	if (args.Length() != 1) {
		// Throw an Error that is passed back to JavaScript
		isolate->ThrowException(Exception::TypeError(
			String::NewFromUtf8Literal(isolate, "Wrong number of arguments for OpenAccounts")));
		return;
	}

	// Check the argument types

	if (!args[0]->IsString()) {
		isolate->ThrowException(Exception::TypeError(
			String::NewFromUtf8Literal(isolate, "Wrong argument type for 'datadir'")));
		return;
	}


	String::Utf8Value arg0Obj(isolate, args[0]->ToString(context).ToLocalChecked());
	char *arg0 = *arg0Obj;

	// Call exported Go function, which returns a C string
	char *c = OpenAccounts(arg0);

	Local<String> ret = String::NewFromUtf8(isolate, c).ToLocalChecked();
	args.GetReturnValue().Set(ret);
	delete c;


}

void _ExtractGroupMembershipSignatures(const FunctionCallbackInfo<Value>& args) {
	Isolate* isolate = args.GetIsolate();
        Local<Context> context = isolate->GetCurrentContext();

	if (args.Length() != 1) {
		// Throw an Error that is passed back to JavaScript
		isolate->ThrowException(Exception::TypeError(
			String::NewFromUtf8Literal(isolate, "Wrong number of arguments for ExtractGroupMembershipSignatures")));
		return;
	}

	// Check the argument types

	if (!args[0]->IsString()) {
		isolate->ThrowException(Exception::TypeError(
			String::NewFromUtf8Literal(isolate, "Wrong argument type for 'signaturePairsStr'")));
		return;
	}


	String::Utf8Value arg0Obj(isolate, args[0]->ToString(context).ToLocalChecked());
	char *arg0 = *arg0Obj;

	// Call exported Go function, which returns a C string
	char *c = ExtractGroupMembershipSignatures(arg0);

	Local<String> ret = String::NewFromUtf8(isolate, c).ToLocalChecked();
	args.GetReturnValue().Set(ret);
	delete c;

}

void _CallPrivateRPC(const FunctionCallbackInfo<Value>& args) {
	Isolate* isolate = args.GetIsolate();
        Local<Context> context = isolate->GetCurrentContext();

	if (args.Length() != 1) {
		// Throw an Error that is passed back to JavaScript
		isolate->ThrowException(Exception::TypeError(
			String::NewFromUtf8Literal(isolate, "Wrong number of arguments for CallPrivateRPC")));
		return;
	}

	// Check the argument types

	if (!args[0]->IsString()) {
		isolate->ThrowException(Exception::TypeError(
			String::NewFromUtf8Literal(isolate, "Wrong argument type for 'inputJSON'")));
		return;
	}


	String::Utf8Value arg0Obj(isolate, args[0]->ToString(context).ToLocalChecked());
	char *arg0 = *arg0Obj;

	// Call exported Go function, which returns a C string
	char *c = CallPrivateRPC(arg0);

	Local<String> ret = String::NewFromUtf8(isolate, c).ToLocalChecked();
	args.GetReturnValue().Set(ret);
	delete c;

}

void _VerifyAccountPassword(const FunctionCallbackInfo<Value>& args) {
	Isolate* isolate = args.GetIsolate();
        Local<Context> context = isolate->GetCurrentContext();

	if (args.Length() != 3) {
		// Throw an Error that is passed back to JavaScript
		isolate->ThrowException(Exception::TypeError(
			String::NewFromUtf8Literal(isolate, "Wrong number of arguments for VerifyAccountPassword")));
		return;
	}

	// Check the argument types

	if (!args[0]->IsString()) {
		isolate->ThrowException(Exception::TypeError(
			String::NewFromUtf8Literal(isolate, "Wrong argument type for 'keyStoreDir'")));
		return;
	}
	if (!args[1]->IsString()) {
		isolate->ThrowException(Exception::TypeError(
			String::NewFromUtf8Literal(isolate, "Wrong argument type for 'address'")));
		return;
	}
	if (!args[2]->IsString()) {
		isolate->ThrowException(Exception::TypeError(
			String::NewFromUtf8Literal(isolate, "Wrong argument type for 'password'")));
		return;
	}


	String::Utf8Value arg0Obj(isolate, args[0]->ToString(context).ToLocalChecked());
	char *arg0 = *arg0Obj;
	String::Utf8Value arg1Obj(isolate, args[1]->ToString(context).ToLocalChecked());
	char *arg1 = *arg1Obj;
	String::Utf8Value arg2Obj(isolate, args[2]->ToString(context).ToLocalChecked());
	char *arg2 = *arg2Obj;

	// Call exported Go function, which returns a C string
	char *c = VerifyAccountPassword(arg0, arg1, arg2);

	Local<String> ret = String::NewFromUtf8(isolate, c).ToLocalChecked();
	args.GetReturnValue().Set(ret);
	delete c;


}

void _SendTransactionWithSignature(const FunctionCallbackInfo<Value>& args) {
	Isolate* isolate = args.GetIsolate();
        Local<Context> context = isolate->GetCurrentContext();

	if (args.Length() != 2) {
		// Throw an Error that is passed back to JavaScript
		isolate->ThrowException(Exception::TypeError(
			String::NewFromUtf8Literal(isolate, "Wrong number of arguments for SendTransactionWithSignature")));
		return;
	}

	// Check the argument types

	if (!args[0]->IsString()) {
		isolate->ThrowException(Exception::TypeError(
			String::NewFromUtf8Literal(isolate, "Wrong argument type for 'txArgsJSON'")));
		return;
	}
	if (!args[1]->IsString()) {
		isolate->ThrowException(Exception::TypeError(
			String::NewFromUtf8Literal(isolate, "Wrong argument type for 'sigString'")));
		return;
	}


	String::Utf8Value arg0Obj(isolate, args[0]->ToString(context).ToLocalChecked());
	char *arg0 = *arg0Obj;
	String::Utf8Value arg1Obj(isolate, args[1]->ToString(context).ToLocalChecked());
	char *arg1 = *arg1Obj;

	// Call exported Go function, which returns a C string
	char *c = SendTransactionWithSignature(arg0, arg1);

	Local<String> ret = String::NewFromUtf8(isolate, c).ToLocalChecked();
	args.GetReturnValue().Set(ret);
	delete c;


}

void _WriteHeapProfile(const FunctionCallbackInfo<Value>& args) {
	Isolate* isolate = args.GetIsolate();
        Local<Context> context = isolate->GetCurrentContext();

	if (args.Length() != 1) {
		// Throw an Error that is passed back to JavaScript
		isolate->ThrowException(Exception::TypeError(
			String::NewFromUtf8Literal(isolate, "Wrong number of arguments for WriteHeapProfile")));
		return;
	}

	// Check the argument types

	if (!args[0]->IsString()) {
		isolate->ThrowException(Exception::TypeError(
			String::NewFromUtf8Literal(isolate, "Wrong argument type for 'dataDir'")));
		return;
	}


	String::Utf8Value arg0Obj(isolate, args[0]->ToString(context).ToLocalChecked());
	char *arg0 = *arg0Obj;

	// Call exported Go function, which returns a C string
	char *c = WriteHeapProfile(arg0);

	Local<String> ret = String::NewFromUtf8(isolate, c).ToLocalChecked();
	args.GetReturnValue().Set(ret);
	delete c;


}

void _AddPeer(const FunctionCallbackInfo<Value>& args) {
	Isolate* isolate = args.GetIsolate();
        Local<Context> context = isolate->GetCurrentContext();

	if (args.Length() != 1) {
		// Throw an Error that is passed back to JavaScript
		isolate->ThrowException(Exception::TypeError(
			String::NewFromUtf8Literal(isolate, "Wrong number of arguments for AddPeer")));
		return;
	}

	// Check the argument types

	if (!args[0]->IsString()) {
		isolate->ThrowException(Exception::TypeError(
			String::NewFromUtf8Literal(isolate, "Wrong argument type for 'enode'")));
		return;
	}


	String::Utf8Value arg0Obj(isolate, args[0]->ToString(context).ToLocalChecked());
	char *arg0 = *arg0Obj;

	// Call exported Go function, which returns a C string
	char *c = AddPeer(arg0);

	Local<String> ret = String::NewFromUtf8(isolate, c).ToLocalChecked();
	args.GetReturnValue().Set(ret);
	delete c;


}

void _SignHash(const FunctionCallbackInfo<Value>& args) {
	Isolate* isolate = args.GetIsolate();
        Local<Context> context = isolate->GetCurrentContext();

	if (args.Length() != 1) {
		// Throw an Error that is passed back to JavaScript
		isolate->ThrowException(Exception::TypeError(
			String::NewFromUtf8Literal(isolate, "Wrong number of arguments for SignHash")));
		return;
	}

	// Check the argument types

	if (!args[0]->IsString()) {
		isolate->ThrowException(Exception::TypeError(
			String::NewFromUtf8Literal(isolate, "Wrong argument type for 'hexEncodedHash'")));
		return;
	}


	String::Utf8Value arg0Obj(isolate, args[0]->ToString(context).ToLocalChecked());
	char *arg0 = *arg0Obj;

	// Call exported Go function, which returns a C string
	char *c = SignHash(arg0);

	Local<String> ret = String::NewFromUtf8(isolate, c).ToLocalChecked();
	args.GetReturnValue().Set(ret);
	delete c;


}

void _SignGroupMembership(const FunctionCallbackInfo<Value>& args) {
	Isolate* isolate = args.GetIsolate();
        Local<Context> context = isolate->GetCurrentContext();

	if (args.Length() != 1) {
		// Throw an Error that is passed back to JavaScript
		isolate->ThrowException(Exception::TypeError(
			String::NewFromUtf8Literal(isolate, "Wrong number of arguments for SignGroupMembership")));
		return;
	}

	// Check the argument types

	if (!args[0]->IsString()) {
		isolate->ThrowException(Exception::TypeError(
			String::NewFromUtf8Literal(isolate, "Wrong argument type for 'content'")));
		return;
	}


	String::Utf8Value arg0Obj(isolate, args[0]->ToString(context).ToLocalChecked());
	char *arg0 = *arg0Obj;

	// Call exported Go function, which returns a C string
	char *c = SignGroupMembership(arg0);

	Local<String> ret = String::NewFromUtf8(isolate, c).ToLocalChecked();
	args.GetReturnValue().Set(ret);
	delete c;


}

void _CallRPC(const FunctionCallbackInfo<Value>& args) {
	Isolate* isolate = args.GetIsolate();
        Local<Context> context = isolate->GetCurrentContext();

	if (args.Length() != 1) {
		// Throw an Error that is passed back to JavaScript
		isolate->ThrowException(Exception::TypeError(
			String::NewFromUtf8Literal(isolate, "Wrong number of arguments for CallRPC")));
		return;
	}

	// Check the argument types

	if (!args[0]->IsString()) {
		isolate->ThrowException(Exception::TypeError(
			String::NewFromUtf8Literal(isolate, "Wrong argument type for 'inputJSON'")));
		return;
	}


	String::Utf8Value arg0Obj(isolate, args[0]->ToString(context).ToLocalChecked());
	char *arg0 = *arg0Obj;

	// Call exported Go function, which returns a C string
	char *c = CallRPC(arg0);

	Local<String> ret = String::NewFromUtf8(isolate, c).ToLocalChecked();
	args.GetReturnValue().Set(ret);
	delete c;


}

void _SignMessage(const FunctionCallbackInfo<Value>& args) {
	Isolate* isolate = args.GetIsolate();
        Local<Context> context = isolate->GetCurrentContext();

	if (args.Length() != 1) {
		// Throw an Error that is passed back to JavaScript
		isolate->ThrowException(Exception::TypeError(
			String::NewFromUtf8Literal(isolate, "Wrong number of arguments for SignMessage")));
		return;
	}

	// Check the argument types

	if (!args[0]->IsString()) {
		isolate->ThrowException(Exception::TypeError(
			String::NewFromUtf8Literal(isolate, "Wrong argument type for 'rpcParams'")));
		return;
	}


	String::Utf8Value arg0Obj(isolate, args[0]->ToString(context).ToLocalChecked());
	char *arg0 = *arg0Obj;

	// Call exported Go function, which returns a C string
	char *c = SignMessage(arg0);

	Local<String> ret = String::NewFromUtf8(isolate, c).ToLocalChecked();
	args.GetReturnValue().Set(ret);
	delete c;


}

void _SignTypedData(const FunctionCallbackInfo<Value>& args) {
	Isolate* isolate = args.GetIsolate();
        Local<Context> context = isolate->GetCurrentContext();

	if (args.Length() != 3) {
		// Throw an Error that is passed back to JavaScript
		isolate->ThrowException(Exception::TypeError(
			String::NewFromUtf8Literal(isolate, "Wrong number of arguments for SignTypedData")));
		return;
	}

	// Check the argument types

	if (!args[0]->IsString()) {
		isolate->ThrowException(Exception::TypeError(
			String::NewFromUtf8Literal(isolate, "Wrong argument type for 'data'")));
		return;
	}
	if (!args[1]->IsString()) {
		isolate->ThrowException(Exception::TypeError(
			String::NewFromUtf8Literal(isolate, "Wrong argument type for 'address'")));
		return;
	}
	if (!args[2]->IsString()) {
		isolate->ThrowException(Exception::TypeError(
			String::NewFromUtf8Literal(isolate, "Wrong argument type for 'password'")));
		return;
	}


	String::Utf8Value arg0Obj(isolate, args[0]->ToString(context).ToLocalChecked());
	char *arg0 = *arg0Obj;
	String::Utf8Value arg1Obj(isolate, args[1]->ToString(context).ToLocalChecked());
	char *arg1 = *arg1Obj;
	String::Utf8Value arg2Obj(isolate, args[2]->ToString(context).ToLocalChecked());
	char *arg2 = *arg2Obj;

	// Call exported Go function, which returns a C string
	char *c = SignTypedData(arg0, arg1, arg2);

	Local<String> ret = String::NewFromUtf8(isolate, c).ToLocalChecked();
	args.GetReturnValue().Set(ret);
	delete c;


}

void _SendTransaction(const FunctionCallbackInfo<Value>& args) {
	Isolate* isolate = args.GetIsolate();
        Local<Context> context = isolate->GetCurrentContext();

	if (args.Length() != 2) {
		// Throw an Error that is passed back to JavaScript
		isolate->ThrowException(Exception::TypeError(
			String::NewFromUtf8Literal(isolate, "Wrong number of arguments for SendTransaction")));
		return;
	}

	// Check the argument types

	if (!args[0]->IsString()) {
		isolate->ThrowException(Exception::TypeError(
			String::NewFromUtf8Literal(isolate, "Wrong argument type for 'txArgsJSON'")));
		return;
	}
	if (!args[1]->IsString()) {
		isolate->ThrowException(Exception::TypeError(
			String::NewFromUtf8Literal(isolate, "Wrong argument type for 'password'")));
		return;
	}


	String::Utf8Value arg0Obj(isolate, args[0]->ToString(context).ToLocalChecked());
	char *arg0 = *arg0Obj;
	String::Utf8Value arg1Obj(isolate, args[1]->ToString(context).ToLocalChecked());
	char *arg1 = *arg1Obj;

	// Call exported Go function, which returns a C string
	char *c = SendTransaction(arg0, arg1);

	Local<String> ret = String::NewFromUtf8(isolate, c).ToLocalChecked();
	args.GetReturnValue().Set(ret);
	delete c;


}

void _AppStateChange(const FunctionCallbackInfo<Value>& args) {
	Isolate* isolate = args.GetIsolate();
        Local<Context> context = isolate->GetCurrentContext();

	if (args.Length() != 1) {
		// Throw an Error that is passed back to JavaScript
		isolate->ThrowException(Exception::TypeError(
			String::NewFromUtf8Literal(isolate, "Wrong number of arguments for AppStateChange")));
		return;
	}

	// Check the argument types

	if (!args[0]->IsString()) {
		isolate->ThrowException(Exception::TypeError(
			String::NewFromUtf8Literal(isolate, "Wrong argument type for 'state'")));
		return;
	}


	String::Utf8Value arg0Obj(isolate, args[0]->ToString(context).ToLocalChecked());
	char *arg0 = *arg0Obj;

	// Call exported Go function, which returns a C string
	AppStateChange(arg0);




}

void _ValidateNodeConfig(const FunctionCallbackInfo<Value>& args) {
	Isolate* isolate = args.GetIsolate();
        Local<Context> context = isolate->GetCurrentContext();

	if (args.Length() != 1) {
		// Throw an Error that is passed back to JavaScript
		isolate->ThrowException(Exception::TypeError(
			String::NewFromUtf8Literal(isolate, "Wrong number of arguments for ValidateNodeConfig")));
		return;
	}

	// Check the argument types

	if (!args[0]->IsString()) {
		isolate->ThrowException(Exception::TypeError(
			String::NewFromUtf8Literal(isolate, "Wrong argument type for 'configJSON'")));
		return;
	}


	String::Utf8Value arg0Obj(isolate, args[0]->ToString(context).ToLocalChecked());
	char *arg0 = *arg0Obj;

	// Call exported Go function, which returns a C string
	char *c = ValidateNodeConfig(arg0);

	Local<String> ret = String::NewFromUtf8(isolate, c).ToLocalChecked();
	args.GetReturnValue().Set(ret);
	delete c;


}

void _HashTypedData(const FunctionCallbackInfo<Value>& args) {
	Isolate* isolate = args.GetIsolate();
        Local<Context> context = isolate->GetCurrentContext();

	if (args.Length() != 1) {
		// Throw an Error that is passed back to JavaScript
		isolate->ThrowException(Exception::TypeError(
			String::NewFromUtf8Literal(isolate, "Wrong number of arguments for HashTypedData")));
		return;
	}

	// Check the argument types

	if (!args[0]->IsString()) {
		isolate->ThrowException(Exception::TypeError(
			String::NewFromUtf8Literal(isolate, "Wrong argument type for 'data'")));
		return;
	}


	String::Utf8Value arg0Obj(isolate, args[0]->ToString(context).ToLocalChecked());
	char *arg0 = *arg0Obj;

	// Call exported Go function, which returns a C string
	char *c = HashTypedData(arg0);

	Local<String> ret = String::NewFromUtf8(isolate, c).ToLocalChecked();
	args.GetReturnValue().Set(ret);
	delete c;


}

void _Recover(const FunctionCallbackInfo<Value>& args) {
	Isolate* isolate = args.GetIsolate();
        Local<Context> context = isolate->GetCurrentContext();

	if (args.Length() != 1) {
		// Throw an Error that is passed back to JavaScript
		isolate->ThrowException(Exception::TypeError(
			String::NewFromUtf8Literal(isolate, "Wrong number of arguments for Recover")));
		return;
	}

	// Check the argument types

	if (!args[0]->IsString()) {
		isolate->ThrowException(Exception::TypeError(
			String::NewFromUtf8Literal(isolate, "Wrong argument type for 'rpcParams'")));
		return;
	}


	String::Utf8Value arg0Obj(isolate, args[0]->ToString(context).ToLocalChecked());
	char *arg0 = *arg0Obj;

	// Call exported Go function, which returns a C string
	char *c = Recover(arg0);

	Local<String> ret = String::NewFromUtf8(isolate, c).ToLocalChecked();
	args.GetReturnValue().Set(ret);
	delete c;


}

void _HashTransaction(const FunctionCallbackInfo<Value>& args) {
	Isolate* isolate = args.GetIsolate();
        Local<Context> context = isolate->GetCurrentContext();

	if (args.Length() != 1) {
		// Throw an Error that is passed back to JavaScript
		isolate->ThrowException(Exception::TypeError(
			String::NewFromUtf8Literal(isolate, "Wrong number of arguments for HashTransaction")));
		return;
	}

	// Check the argument types

	if (!args[0]->IsString()) {
		isolate->ThrowException(Exception::TypeError(
			String::NewFromUtf8Literal(isolate, "Wrong argument type for 'txArgsJSON'")));
		return;
	}


	String::Utf8Value arg0Obj(isolate, args[0]->ToString(context).ToLocalChecked());
	char *arg0 = *arg0Obj;

	// Call exported Go function, which returns a C string
	char *c = HashTransaction(arg0);

	Local<String> ret = String::NewFromUtf8(isolate, c).ToLocalChecked();
	args.GetReturnValue().Set(ret);
	delete c;
}

void _ConnectionChange(const FunctionCallbackInfo<Value>& args) {
	Isolate* isolate = args.GetIsolate();
        Local<Context> context = isolate->GetCurrentContext();

	if (args.Length() != 2) {
		// Throw an Error that is passed back to JavaScript
		isolate->ThrowException(Exception::TypeError(
			String::NewFromUtf8Literal(isolate, "Wrong number of arguments for ConnectionChange")));
		return;
	}

	// Check the argument types

	if (!args[0]->IsString()) {
		isolate->ThrowException(Exception::TypeError(
			String::NewFromUtf8Literal(isolate, "Wrong argument type for 'typ'")));
		return;
	}
	if (!args[1]->IsNumber()) {
		isolate->ThrowException(Exception::TypeError(
			String::NewFromUtf8Literal(isolate, "Wrong argument type for 'expensive'")));
		return;
	}


	String::Utf8Value arg0Obj(isolate, args[0]->ToString(context).ToLocalChecked());
	char *arg0 = *arg0Obj;
	int arg1 = args[1]->Int32Value(context).ToChecked();

	// Call exported Go function, which returns a C string
	ConnectionChange(arg0, arg1);
}


void init(Local<Object> exports) {
	NODE_SET_METHOD(exports, "MultiAccountGenerateAndDeriveAddresses", _MultiAccountGenerateAndDeriveAddresses);
	NODE_SET_METHOD(exports, "MultiAccountImportPrivateKey", _MultiAccountImportPrivateKey);
	NODE_SET_METHOD(exports, "MultiAccountLoadAccount", _MultiAccountLoadAccount);
	NODE_SET_METHOD(exports, "MultiAccountReset", _MultiAccountReset);
	NODE_SET_METHOD(exports, "MultiAccountDeriveAddresses", _MultiAccountDeriveAddresses);
	NODE_SET_METHOD(exports, "MultiAccountImportMnemonic", _MultiAccountImportMnemonic);
	NODE_SET_METHOD(exports, "MultiAccountGenerate", _MultiAccountGenerate);
	NODE_SET_METHOD(exports, "MultiAccountStoreDerivedAccounts", _MultiAccountStoreDerivedAccounts);
	NODE_SET_METHOD(exports, "MultiAccountStoreAccount", _MultiAccountStoreAccount);
	NODE_SET_METHOD(exports, "InitKeystore", _InitKeystore);
	NODE_SET_METHOD(exports, "StopCPUProfiling", _StopCPUProfiling);
	NODE_SET_METHOD(exports, "identicon", _Identicon);
	NODE_SET_METHOD(exports, "Logout", _Logout);
	NODE_SET_METHOD(exports, "HashMessage", _HashMessage);
	NODE_SET_METHOD(exports, "ResetChainData", _ResetChainData);
	NODE_SET_METHOD(exports, "SaveAccountAndLogin", _SaveAccountAndLogin);
	NODE_SET_METHOD(exports, "GenerateAlias", _GenerateAlias);
	NODE_SET_METHOD(exports, "ValidateMnemonic", _ValidateMnemonic);
	NODE_SET_METHOD(exports, "MultiformatSerializePublicKey", _MultiformatSerializePublicKey);
	NODE_SET_METHOD(exports, "SaveAccountAndLoginWithKeycard", _SaveAccountAndLoginWithKeycard);
	NODE_SET_METHOD(exports, "LoginWithKeycard", _LoginWithKeycard);
	NODE_SET_METHOD(exports, "MultiformatDeserializePublicKey", _MultiformatDeserializePublicKey);
	NODE_SET_METHOD(exports, "Login", _Login);
	NODE_SET_METHOD(exports, "StartCPUProfile", _StartCPUProfile);
	NODE_SET_METHOD(exports, "OpenAccounts", _OpenAccounts);
	NODE_SET_METHOD(exports, "ExtractGroupMembershipSignatures", _ExtractGroupMembershipSignatures);
	NODE_SET_METHOD(exports, "CallPrivateRPC", _CallPrivateRPC);
	NODE_SET_METHOD(exports, "VerifyAccountPassword", _VerifyAccountPassword);
	NODE_SET_METHOD(exports, "SendTransactionWithSignature", _SendTransactionWithSignature);
	NODE_SET_METHOD(exports, "WriteHeapProfile", _WriteHeapProfile);
	NODE_SET_METHOD(exports, "AddPeer", _AddPeer);
	NODE_SET_METHOD(exports, "SignHash", _SignHash);
	NODE_SET_METHOD(exports, "SignGroupMembership", _SignGroupMembership);
	NODE_SET_METHOD(exports, "CallRPC", _CallRPC);
	NODE_SET_METHOD(exports, "SignMessage", _SignMessage);
	NODE_SET_METHOD(exports, "SignTypedData", _SignTypedData);
	NODE_SET_METHOD(exports, "SendTransaction", _SendTransaction);
	NODE_SET_METHOD(exports, "AppStateChange", _AppStateChange);
        NODE_SET_METHOD(exports, "SetSignalEventCallback", _SetSignalEventCallback);
	NODE_SET_METHOD(exports, "ValidateNodeConfig", _ValidateNodeConfig);
	NODE_SET_METHOD(exports, "HashTypedData", _HashTypedData);
	NODE_SET_METHOD(exports, "Recover", _Recover);
	NODE_SET_METHOD(exports, "HashTransaction", _HashTransaction);
	NODE_SET_METHOD(exports, "ConnectionChange", _ConnectionChange);

}

NODE_MODULE(NODE_GYP_MODULE_NAME, init)

}  // namespace status
